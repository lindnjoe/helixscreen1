diff --git a/src/core/lv_observer.c b/src/core/lv_observer.c
index 033deb328..f117dd568 100644
--- a/src/core/lv_observer.c
+++ b/src/core/lv_observer.c
@@ -118,7 +118,7 @@ void lv_subject_init_int(lv_subject_t * subject, int32_t value)
 void lv_subject_set_int(lv_subject_t * subject, int32_t value)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -132,7 +132,7 @@ void lv_subject_set_int(lv_subject_t * subject, int32_t value)
 int32_t lv_subject_get_int(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return 0;
     }
 
@@ -142,7 +142,7 @@ int32_t lv_subject_get_int(lv_subject_t * subject)
 int32_t lv_subject_get_previous_int(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return 0;
     }
 
@@ -152,7 +152,7 @@ int32_t lv_subject_get_previous_int(lv_subject_t * subject)
 void lv_subject_set_min_value_int(lv_subject_t * subject, int32_t min_value)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -162,7 +162,7 @@ void lv_subject_set_min_value_int(lv_subject_t * subject, int32_t min_value)
 void lv_subject_set_max_value_int(lv_subject_t * subject, int32_t max_value)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_INT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -185,7 +185,7 @@ void lv_subject_init_float(lv_subject_t * subject, float value)
 void lv_subject_set_float(lv_subject_t * subject, float value)
 {
     if(subject->type != LV_SUBJECT_TYPE_FLOAT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -199,7 +199,7 @@ void lv_subject_set_float(lv_subject_t * subject, float value)
 float lv_subject_get_float(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_FLOAT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return 0;
     }
 
@@ -209,7 +209,7 @@ float lv_subject_get_float(lv_subject_t * subject)
 float lv_subject_get_previous_float(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_FLOAT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return 0;
     }
 
@@ -219,7 +219,7 @@ float lv_subject_get_previous_float(lv_subject_t * subject)
 void lv_subject_set_min_value_float(lv_subject_t * subject, float min_value)
 {
     if(subject->type != LV_SUBJECT_TYPE_FLOAT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -229,7 +229,7 @@ void lv_subject_set_min_value_float(lv_subject_t * subject, float min_value)
 void lv_subject_set_max_value_float(lv_subject_t * subject, float max_value)
 {
     if(subject->type != LV_SUBJECT_TYPE_FLOAT) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_FLOAT (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -256,7 +256,7 @@ void lv_subject_init_string(lv_subject_t * subject, char * buf, char * prev_buf,
 void lv_subject_copy_string(lv_subject_t * subject, const char * buf)
 {
     if(subject->type != LV_SUBJECT_TYPE_STRING) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_STRING");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_STRING (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -273,7 +273,7 @@ void lv_subject_copy_string(lv_subject_t * subject, const char * buf)
 void lv_subject_snprintf(lv_subject_t * subject, const char * format, ...)
 {
     if(subject->type != LV_SUBJECT_TYPE_STRING) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_STRING");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_STRING (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -295,7 +295,7 @@ void lv_subject_snprintf(lv_subject_t * subject, const char * format, ...)
 const char * lv_subject_get_string(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_STRING) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_STRING");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_STRING (ptr=%p, type=%d)", (void*)subject, subject->type);
         return "";
     }
 
@@ -305,7 +305,7 @@ const char * lv_subject_get_string(lv_subject_t * subject)
 const char * lv_subject_get_previous_string(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_STRING) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_STRING");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_STRING (ptr=%p, type=%d)", (void*)subject, subject->type);
         return NULL;
     }
 
@@ -324,7 +324,7 @@ void lv_subject_init_pointer(lv_subject_t * subject, void * value)
 void lv_subject_set_pointer(lv_subject_t * subject, void * ptr)
 {
     if(subject->type != LV_SUBJECT_TYPE_POINTER) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_POINTER");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_POINTER (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -336,7 +336,7 @@ void lv_subject_set_pointer(lv_subject_t * subject, void * ptr)
 const void * lv_subject_get_pointer(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_POINTER) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_POINTER");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_POINTER (ptr=%p, type=%d)", (void*)subject, subject->type);
         return NULL;
     }
 
@@ -346,7 +346,7 @@ const void * lv_subject_get_pointer(lv_subject_t * subject)
 const void * lv_subject_get_previous_pointer(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_POINTER) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_POINTER");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_POINTER (ptr=%p, type=%d)", (void*)subject, subject->type);
         return NULL;
     }
 
@@ -365,7 +365,7 @@ void lv_subject_init_color(lv_subject_t * subject, lv_color_t color)
 void lv_subject_set_color(lv_subject_t * subject, lv_color_t color)
 {
     if(subject->type != LV_SUBJECT_TYPE_COLOR) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_COLOR");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_COLOR (ptr=%p, type=%d)", (void*)subject, subject->type);
         return;
     }
 
@@ -377,7 +377,7 @@ void lv_subject_set_color(lv_subject_t * subject, lv_color_t color)
 lv_color_t lv_subject_get_color(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_COLOR) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_COLOR");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_COLOR (ptr=%p, type=%d)", (void*)subject, subject->type);
         return lv_color_black();
     }
 
@@ -387,7 +387,7 @@ lv_color_t lv_subject_get_color(lv_subject_t * subject)
 lv_color_t lv_subject_get_previous_color(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_COLOR) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_COLOR");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_COLOR (ptr=%p, type=%d)", (void*)subject, subject->type);
         return lv_color_black();
     }
 
@@ -425,7 +425,7 @@ void lv_subject_deinit(lv_subject_t * subject)
 lv_subject_t * lv_subject_get_group_element(lv_subject_t * subject, int32_t index)
 {
     if(subject->type != LV_SUBJECT_TYPE_GROUP) {
-        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_GROUP");
+        LV_LOG_WARN("Subject type is not LV_SUBJECT_TYPE_GROUP (ptr=%p, type=%d)", (void*)subject, subject->type);
         return NULL;
     }
 
diff --git a/src/draw/sw/blend/lv_draw_sw_blend.c b/src/draw/sw/blend/lv_draw_sw_blend.c
index 54a7294ac..5698d193b 100644
--- a/src/draw/sw/blend/lv_draw_sw_blend.c
+++ b/src/draw/sw/blend/lv_draw_sw_blend.c
@@ -81,6 +81,11 @@ void lv_draw_sw_blend(lv_draw_task_t * t, const lv_draw_sw_blend_dsc_t * blend_d
 
     LV_PROFILER_DRAW_BEGIN;
     lv_layer_t * layer = t->target_layer;
+    if(layer == NULL || layer->draw_buf == NULL) {
+        LV_LOG_WARN("lv_draw_sw_blend: target layer or draw_buf is NULL, skipping");
+        LV_PROFILER_DRAW_END;
+        return;
+    }
     uint32_t layer_stride_byte = layer->draw_buf->header.stride;
 
     lv_draw_sw_blend_handler_t handler = lv_draw_sw_get_blend_handler(layer->color_format);
diff --git a/src/draw/sw/blend/lv_draw_sw_blend_to_rgb888.c b/src/draw/sw/blend/lv_draw_sw_blend_to_rgb888.c
index c92ce07df..35aff0b54 100644
--- a/src/draw/sw/blend/lv_draw_sw_blend_to_rgb888.c
+++ b/src/draw/sw/blend/lv_draw_sw_blend_to_rgb888.c
@@ -223,6 +223,10 @@ static inline void * /* LV_ATTRIBUTE_FAST_MEM */ drawbuf_next_row(const void * b
 
 void LV_ATTRIBUTE_FAST_MEM lv_draw_sw_blend_color_to_rgb888(lv_draw_sw_blend_fill_dsc_t * dsc, uint32_t dest_px_size)
 {
+    if(dsc->dest_buf == NULL || dsc->dest_w <= 0 || dsc->dest_h <= 0) {
+        LV_LOG_WARN("lv_draw_sw_blend_color_to_rgb888: NULL dest_buf or invalid dimensions, skipping");
+        return;
+    }
     int32_t w = dsc->dest_w;
     int32_t h = dsc->dest_h;
     lv_opa_t opa = dsc->opa;
diff --git a/src/draw/sw/lv_draw_sw_letter.c b/src/draw/sw/lv_draw_sw_letter.c
index c57632b7a..d9f381fc3 100644
--- a/src/draw/sw/lv_draw_sw_letter.c
+++ b/src/draw/sw/lv_draw_sw_letter.c
@@ -108,6 +108,11 @@ void lv_draw_sw_label(lv_draw_task_t * t, const lv_draw_label_dsc_t * dsc, const
 {
     if(dsc->opa <= LV_OPA_MIN) return;
 
+    if(dsc->font == NULL) {
+        LV_LOG_WARN("lv_draw_sw_label: NULL font, skipping");
+        return;
+    }
+
     LV_PROFILER_DRAW_BEGIN;
 
 #if LV_USE_FREETYPE && LV_USE_VECTOR_GRAPHIC && LV_USE_THORVG
@@ -150,6 +155,13 @@ static void LV_ATTRIBUTE_FAST_MEM draw_letter_cb(lv_draw_task_t * t, lv_draw_gly
             case LV_FONT_GLYPH_FORMAT_A4:
             case LV_FONT_GLYPH_FORMAT_A8:
             case LV_FONT_GLYPH_FORMAT_IMAGE: {
+                    /* Guard against stale draw tasks referencing freed glyph descriptors.
+                     * This can happen when a widget is deleted while a draw task is still
+                     * queued (e.g., panel navigation deletes arc+label during redraw). */
+                    if(glyph_draw_dsc->g == NULL || glyph_draw_dsc->letter_coords == NULL) {
+                        LV_LOG_WARN("Skipping glyph draw: null glyph descriptor or letter coords");
+                        break;
+                    }
                     if(glyph_draw_dsc->rotation % 3600 == 0 && glyph_draw_dsc->format != LV_FONT_GLYPH_FORMAT_IMAGE) {
                         lv_area_t mask_area = *glyph_draw_dsc->letter_coords;
 
diff --git a/src/drivers/display/drm/lv_linux_drm.c b/src/drivers/display/drm/lv_linux_drm.c
index 2a6ca6ed0..089b34b74 100644
--- a/src/drivers/display/drm/lv_linux_drm.c
+++ b/src/drivers/display/drm/lv_linux_drm.c
@@ -78,6 +78,7 @@ typedef struct {
     drmModePropertyPtr conn_props[128];
     drm_buffer_t drm_bufs[BUFFER_CNT];
     drm_buffer_t * act_buf;
+    uint64_t plane_rotation; /* DRM_MODE_ROTATE_* bitmask, 0 = unset */
 #if LV_USE_LINUX_DRM_GBM_BUFFERS
     struct gbm_device * gbm_device;
 #endif
@@ -256,6 +257,43 @@ void lv_linux_drm_set_mode_cb(lv_display_t * disp, lv_linux_drm_select_mode_cb_t
     LV_UNUSED(callback);
     LV_LOG_WARN("DRM without EGL support doesn't currently support setting a mode selection callback");
 }
+
+uint64_t lv_linux_drm_get_plane_rotation_mask(lv_display_t * disp)
+{
+    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    if(drm_dev == NULL) {
+        return 0;
+    }
+
+    uint32_t i;
+    for(i = 0; i < drm_dev->count_plane_props; ++i) {
+        if(lv_strcmp(drm_dev->plane_props[i]->name, "rotation") == 0) {
+            drmModePropertyPtr prop = drm_dev->plane_props[i];
+            uint64_t mask = 0;
+            int e;
+            for(e = 0; e < prop->count_enums; ++e) {
+                mask |= (1ULL << prop->enums[e].value);
+            }
+            LV_LOG_INFO("DRM plane rotation mask: 0x%x (%d enums)", (unsigned)mask, prop->count_enums);
+            return mask;
+        }
+    }
+
+    LV_LOG_INFO("DRM plane has no rotation property");
+    return 0;
+}
+
+void lv_linux_drm_set_rotation(lv_display_t * disp, uint64_t rotation)
+{
+    drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
+    if(drm_dev == NULL) {
+        LV_LOG_ERROR("DRM display not initialized");
+        return;
+    }
+    drm_dev->plane_rotation = rotation;
+    LV_LOG_INFO("DRM plane rotation set to %u", (unsigned)rotation);
+}
+
 /**********************
  *   STATIC FUNCTIONS
  **********************/
@@ -482,6 +520,10 @@ static int drm_dmabuf_set_plane(drm_dev_t * drm_dev, drm_buffer_t * buf)
     drm_add_plane_property(drm_dev, "CRTC_W", drm_dev->width);
     drm_add_plane_property(drm_dev, "CRTC_H", drm_dev->height);
 
+    if(drm_dev->plane_rotation) {
+        drm_add_plane_property(drm_dev, "rotation", drm_dev->plane_rotation);
+    }
+
     ret = drmModeAtomicCommit(drm_dev->fd, drm_dev->req, flags, drm_dev);
     if(ret) {
         LV_LOG_ERROR("drmModeAtomicCommit failed: %s (%d)", strerror(errno), errno);
@@ -508,7 +550,10 @@ static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane
         return -1;
     }
 
-    LV_LOG_TRACE("drm: found planes %u", planes->count_planes);
+    LV_LOG_INFO("drm: found %u planes, looking for fourcc %c%c%c%c on crtc_idx %u",
+                planes->count_planes,
+                (fourcc >> 0) & 0xff, (fourcc >> 8) & 0xff,
+                (fourcc >> 16) & 0xff, (fourcc >> 24) & 0xff, crtc_idx);
 
     for(i = 0; i < planes->count_planes; ++i) {
         plane = drmModeGetPlane(drm_dev->fd, planes->planes[i]);
@@ -519,6 +564,8 @@ static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane
         }
 
         if(!(plane->possible_crtcs & (1 << crtc_idx))) {
+            LV_LOG_INFO("drm: plane %u: crtc_mask=0x%x, skipping (need bit %u)",
+                        plane->plane_id, plane->possible_crtcs, crtc_idx);
             drmModeFreePlane(plane);
             continue;
         }
@@ -529,6 +576,8 @@ static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane
         }
 
         if(j == plane->count_formats) {
+            LV_LOG_INFO("drm: plane %u: no matching fourcc among %u formats",
+                        plane->plane_id, plane->count_formats);
             drmModeFreePlane(plane);
             continue;
         }
@@ -536,7 +585,7 @@ static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane
         *plane_id = plane->plane_id;
         drmModeFreePlane(plane);
 
-        LV_LOG_TRACE("found plane %d", *plane_id);
+        LV_LOG_INFO("drm: found suitable plane %d", *plane_id);
 
         /* Success */
         goto out;
@@ -579,16 +628,16 @@ static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
         }
 
         if(conn->connection == DRM_MODE_CONNECTED) {
-            LV_LOG_TRACE("drm: connector %d: connected", conn->connector_id);
+            LV_LOG_INFO("drm: connector %d: connected (%d modes)", conn->connector_id, conn->count_modes);
         }
         else if(conn->connection == DRM_MODE_DISCONNECTED) {
-            LV_LOG_TRACE("drm: connector %d: disconnected", conn->connector_id);
+            LV_LOG_INFO("drm: connector %d: disconnected", conn->connector_id);
         }
         else if(conn->connection == DRM_MODE_UNKNOWNCONNECTION) {
-            LV_LOG_TRACE("drm: connector %d: unknownconnection", conn->connector_id);
+            LV_LOG_INFO("drm: connector %d: unknownconnection", conn->connector_id);
         }
         else {
-            LV_LOG_TRACE("drm: connector %d: unknown", conn->connector_id);
+            LV_LOG_INFO("drm: connector %d: unknown", conn->connector_id);
         }
 
         if(conn->connection == DRM_MODE_CONNECTED && conn->count_modes > 0)
@@ -604,7 +653,7 @@ static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
     }
 
     drm_dev->conn_id = conn->connector_id;
-    LV_LOG_TRACE("conn_id: %d", drm_dev->conn_id);
+    LV_LOG_INFO("drm: using connector %d", drm_dev->conn_id);
     drm_dev->mmWidth = conn->mmWidth;
     drm_dev->mmHeight = conn->mmHeight;
 
@@ -635,9 +684,8 @@ static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
 
     if(enc) {
         drm_dev->enc_id = enc->encoder_id;
-        LV_LOG_TRACE("enc_id: %d", drm_dev->enc_id);
         drm_dev->crtc_id = enc->crtc_id;
-        LV_LOG_TRACE("crtc_id: %d", drm_dev->crtc_id);
+        LV_LOG_INFO("drm: encoder %d, crtc %d", drm_dev->enc_id, drm_dev->crtc_id);
         drmModeFreeEncoder(enc);
         enc = NULL;
     }
@@ -698,7 +746,7 @@ static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
         goto free_res;
     }
 
-    LV_LOG_TRACE("crtc_idx: %d", drm_dev->crtc_idx);
+    LV_LOG_INFO("drm: crtc_idx: %d", drm_dev->crtc_idx);
     ret = 0;
 
 free_res:
diff --git a/src/drivers/display/drm/lv_linux_drm.h b/src/drivers/display/drm/lv_linux_drm.h
index 5afede049..fa1b28b56 100644
--- a/src/drivers/display/drm/lv_linux_drm.h
+++ b/src/drivers/display/drm/lv_linux_drm.h
@@ -90,6 +90,30 @@ char * lv_linux_drm_find_device_path(void);
  */
 void lv_linux_drm_set_mode_cb(lv_display_t * disp, lv_linux_drm_select_mode_cb_t callback);
 
+/**
+ * @brief Query the DRM plane's supported rotation bitmask
+ *
+ * Iterates the plane properties to find the "rotation" property and builds
+ * a bitmask from its enum values. Returns 0 if no rotation property exists.
+ *
+ * @param disp      Pointer to the display object created with lv_linux_drm_create()
+ * @return Bitmask of supported DRM_MODE_ROTATE_* values, or 0
+ */
+uint64_t lv_linux_drm_get_plane_rotation_mask(lv_display_t * disp);
+
+/**
+ * @brief Set the DRM plane rotation property
+ *
+ * Configures the hardware rotation via the DRM plane "rotation" property.
+ * This is necessary because LVGL's software rotation (lv_display_set_rotation)
+ * does not work with LV_DISPLAY_RENDER_MODE_DIRECT used by the DRM backend.
+ *
+ * @param disp      Pointer to the display object created with lv_linux_drm_create()
+ * @param rotation  DRM rotation bitmask (DRM_MODE_ROTATE_0, DRM_MODE_ROTATE_90,
+ *                  DRM_MODE_ROTATE_180, DRM_MODE_ROTATE_270)
+ */
+void lv_linux_drm_set_rotation(lv_display_t * disp, uint64_t rotation);
+
 /**
  * Get the horizontal resolution of a DRM mode
  * @param mode pointer to the DRM mode object
@@ -118,6 +142,29 @@ int32_t lv_linux_drm_mode_get_refresh_rate(const lv_linux_drm_mode_t * mode);
  */
 bool lv_linux_drm_mode_is_preferred(const lv_linux_drm_mode_t * mode);
 
+#if LV_LINUX_DRM_USE_EGL
+/**
+ * Get the EGL display from a DRM display (cast to EGLDisplay)
+ * @param disp pointer to the display object
+ * @return EGLDisplay as void*, or NULL if not using EGL
+ */
+void * lv_linux_drm_get_egl_display(lv_display_t * disp);
+
+/**
+ * Get the EGL context from a DRM display (cast to EGLContext)
+ * @param disp pointer to the display object
+ * @return EGLContext as void*, or NULL if not using EGL
+ */
+void * lv_linux_drm_get_egl_context(lv_display_t * disp);
+
+/**
+ * Get the EGL config from a DRM display (cast to EGLConfig)
+ * @param disp pointer to the display object
+ * @return EGLConfig as void*, or NULL if not using EGL
+ */
+void * lv_linux_drm_get_egl_config(lv_display_t * disp);
+#endif
+
 /**********************
  *      MACROS
  **********************/
diff --git a/src/drivers/display/drm/lv_linux_drm_egl.c b/src/drivers/display/drm/lv_linux_drm_egl.c
index 546256611..66e665d32 100644
--- a/src/drivers/display/drm/lv_linux_drm_egl.c
+++ b/src/drivers/display/drm/lv_linux_drm_egl.c
@@ -757,4 +757,28 @@ static void drm_destroy_window(void * driver_data, void * native_window)
 }
 
 
+void * lv_linux_drm_get_egl_display(lv_display_t * disp)
+{
+    if(!disp) return NULL;
+    lv_drm_ctx_t * ctx = lv_display_get_driver_data(disp);
+    if(!ctx || !ctx->egl_ctx) return NULL;
+    return (void *)ctx->egl_ctx->egl_display;
+}
+
+void * lv_linux_drm_get_egl_context(lv_display_t * disp)
+{
+    if(!disp) return NULL;
+    lv_drm_ctx_t * ctx = lv_display_get_driver_data(disp);
+    if(!ctx || !ctx->egl_ctx) return NULL;
+    return (void *)ctx->egl_ctx->egl_context;
+}
+
+void * lv_linux_drm_get_egl_config(lv_display_t * disp)
+{
+    if(!disp) return NULL;
+    lv_drm_ctx_t * ctx = lv_display_get_driver_data(disp);
+    if(!ctx || !ctx->egl_ctx) return NULL;
+    return (void *)ctx->egl_ctx->egl_config;
+}
+
 #endif /*LV_USE_LINUX_DRM && LV_LINUX_DRM_USE_EGL*/
diff --git a/src/drivers/display/fb/lv_linux_fbdev.c b/src/drivers/display/fb/lv_linux_fbdev.c
index c78b881f8..0a1184102 100644
--- a/src/drivers/display/fb/lv_linux_fbdev.c
+++ b/src/drivers/display/fb/lv_linux_fbdev.c
@@ -71,6 +71,7 @@ typedef struct {
     bool force_refresh;
     uint8_t * draw_buf_1;
     uint8_t * draw_buf_2;
+    bool skip_unblank;
 } lv_linux_fb_t;
 
 /**********************
@@ -143,10 +144,12 @@ lv_result_t lv_linux_fbdev_set_file(lv_display_t * disp, const char * file)
     }
     LV_LOG_INFO("The framebuffer device was opened successfully");
 
-    /* Make sure that the display is on.*/
-    if(ioctl(dsc->fbfd, FBIOBLANK, FB_BLANK_UNBLANK) != 0) {
-        perror("ioctl(FBIOBLANK)");
-        /* Don't return. Some framebuffer drivers like efifb or simplefb don't implement FBIOBLANK.*/
+    /* Make sure that the display is on (unless another process already owns the framebuffer). */
+    if(!dsc->skip_unblank) {
+        if(ioctl(dsc->fbfd, FBIOBLANK, FB_BLANK_UNBLANK) != 0) {
+            perror("ioctl(FBIOBLANK)");
+            /* Don't return. Some framebuffer drivers like efifb or simplefb don't implement FBIOBLANK.*/
+        }
     }
 
 #if LV_LINUX_FBDEV_BSD
@@ -189,6 +192,23 @@ lv_result_t lv_linux_fbdev_set_file(lv_display_t * disp, const char * file)
 
     LV_LOG_INFO("%dx%d, %dbpp", dsc->vinfo.xres, dsc->vinfo.yres, dsc->vinfo.bits_per_pixel);
 
+    /* AD5M and some other devices report incorrect bits_per_pixel via VSCREENINFO.
+     * The stride (line_length) is always correct, so calculate true bpp from it.
+     * Example: AD5M reports 16bpp but stride=3200 for 800px width = 4 bytes/pixel = 32bpp */
+    uint32_t stride_bpp = 0;
+    if(dsc->vinfo.xres > 0) {
+        stride_bpp = (dsc->finfo.line_length * 8) / dsc->vinfo.xres;
+    }
+
+    if(stride_bpp > 0 && stride_bpp != dsc->vinfo.bits_per_pixel) {
+        LV_LOG_WARN("bits_per_pixel mismatch: vinfo says %d, stride indicates %d. Using stride value.",
+                    dsc->vinfo.bits_per_pixel, stride_bpp);
+        dsc->vinfo.bits_per_pixel = stride_bpp;
+    }
+    else {
+        LV_LOG_INFO("bits_per_pixel %d matches stride calculation", dsc->vinfo.bits_per_pixel);
+    }
+
     /* Figure out the size of the screen in bytes*/
     dsc->screensize =  dsc->finfo.smem_len;/*finfo.line_length * vinfo.yres;*/
 
@@ -256,6 +276,12 @@ lv_result_t lv_linux_fbdev_set_file(lv_display_t * disp, const char * file)
     return LV_RESULT_OK;
 }
 
+void lv_linux_fbdev_set_skip_unblank(lv_display_t * disp, bool skip)
+{
+    lv_linux_fb_t * dsc = lv_display_get_driver_data(disp);
+    dsc->skip_unblank = skip;
+}
+
 void lv_linux_fbdev_set_force_refresh(lv_display_t * disp, bool enabled)
 {
     lv_linux_fb_t * dsc = lv_display_get_driver_data(disp);
diff --git a/src/drivers/display/fb/lv_linux_fbdev.h b/src/drivers/display/fb/lv_linux_fbdev.h
index a9b7be075..da63d4c37 100644
--- a/src/drivers/display/fb/lv_linux_fbdev.h
+++ b/src/drivers/display/fb/lv_linux_fbdev.h
@@ -33,6 +33,14 @@ lv_display_t * lv_linux_fbdev_create(void);
 
 lv_result_t lv_linux_fbdev_set_file(lv_display_t * disp, const char * file);
 
+/**
+ * Skip the FBIOBLANK unblank ioctl in lv_linux_fbdev_set_file().
+ * Use when another process (e.g. splash screen) already owns the framebuffer
+ * and calling FBIOBLANK would cause visible flicker.
+ * Must be called BEFORE lv_linux_fbdev_set_file().
+ */
+void lv_linux_fbdev_set_skip_unblank(lv_display_t * disp, bool skip);
+
 /**
  * Force the display to be refreshed on every change.
  * Expected to be used with LV_DISPLAY_RENDER_MODE_DIRECT or LV_DISPLAY_RENDER_MODE_FULL.
diff --git a/src/drivers/sdl/lv_sdl_window.c b/src/drivers/sdl/lv_sdl_window.c
index 15a87ab12..20bef5b33 100644
--- a/src/drivers/sdl/lv_sdl_window.c
+++ b/src/drivers/sdl/lv_sdl_window.c
@@ -21,6 +21,10 @@
 #define SDL_MAIN_HANDLED /*To fix SDL's "undefined reference to WinMain" issue*/
 #include "lv_sdl_private.h"
 
+#ifdef __ANDROID__
+    #include <android/log.h>
+#endif
+
 #if LV_COLOR_DEPTH == 1 && LV_SDL_RENDER_MODE != LV_DISPLAY_RENDER_MODE_PARTIAL
     #error SDL LV_COLOR_DEPTH 1 requires LV_SDL_RENDER_MODE LV_DISPLAY_RENDER_MODE_PARTIAL
 #endif
@@ -122,7 +126,13 @@ void lv_sdl_window_set_zoom(lv_display_t * disp, float zoom)
 
 float lv_sdl_window_get_zoom(lv_display_t * disp)
 {
+    if(disp == NULL) {
+        return 1.0f;
+    }
     lv_sdl_window_t * dsc = lv_display_get_driver_data(disp);
+    if(dsc == NULL) {
+        return 1.0f;
+    }
     return dsc->zoom;
 }
 
@@ -256,12 +266,18 @@ static void sdl_event_handler(lv_timer_t * t)
                     lv_sdl_backend_ops.redraw(disp);
                     break;
                 case SDL_WINDOWEVENT_RESIZED:
+#ifdef __ANDROID__
+                    /* On Android, SDL_RenderSetLogicalSize handles scaling.
+                     * Don't let native surface resizes change LVGL's logical resolution. */
+                    lv_refr_now(disp);
+#else
                     dsc->ignore_size_chg = 1;
                     int32_t hres = (int32_t)((float)(event.window.data1) / dsc->zoom);
                     int32_t vres = (int32_t)((float)(event.window.data2) / dsc->zoom);
                     lv_display_set_resolution(disp, hres, vres);
                     dsc->ignore_size_chg = 0;
                     lv_refr_now(disp);
+#endif
                     break;
                 case SDL_WINDOWEVENT_CLOSE:
                     lv_display_delete(disp);
@@ -271,9 +287,10 @@ static void sdl_event_handler(lv_timer_t * t)
             }
         }
         if(event.type == SDL_QUIT) {
-            SDL_Quit();
-            lv_deinit();
-            inited = false;
+            /*Don't handle SDL_QUIT here - the application layer handles
+             *Cmd+Q via keyboard state polling and window close via
+             *SDL_WINDOWEVENT_CLOSE. Calling SDL_Quit() from within the
+             *event handler causes a crash on macOS.*/
 #if LV_SDL_DIRECT_EXIT
             exit(0);
 #endif
@@ -294,12 +311,69 @@ static lv_result_t window_create(lv_display_t * disp)
 #if LV_SDL_FULLSCREEN
     flag |= SDL_WINDOW_FULLSCREEN;
 #endif
+#ifdef __ANDROID__
+    /* On Android, always use fullscreen desktop mode so the SDL window
+     * matches the native surface size. Without this, the EGL surface
+     * gets invalidated when Android resizes it, causing EGL_BAD_SURFACE. */
+    flag |= SDL_WINDOW_FULLSCREEN_DESKTOP;
+#endif
 
     int32_t hor_res = (int32_t)((float)(disp->hor_res) * dsc->zoom);
     int32_t ver_res = (int32_t)((float)(disp->ver_res) * dsc->zoom);
-    dsc->window = SDL_CreateWindow("LVGL Simulator",
-                                   SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
+
+    /* Check environment variables for window position */
+    int x_pos = SDL_WINDOWPOS_UNDEFINED;
+    int y_pos = SDL_WINDOWPOS_UNDEFINED;
+
+    const char* display_env = getenv("HELIX_SDL_DISPLAY");
+    const char* xpos_env = getenv("HELIX_SDL_XPOS");
+    const char* ypos_env = getenv("HELIX_SDL_YPOS");
+
+    if (display_env != NULL) {
+        /* Center window on specific display by calculating actual center position */
+        int display_num = atoi(display_env);
+        int num_displays = SDL_GetNumVideoDisplays();
+
+        if (display_num >= 0 && display_num < num_displays) {
+            SDL_Rect display_bounds;
+            if (SDL_GetDisplayBounds(display_num, &display_bounds) == 0) {
+                /* Calculate center position on the display */
+                x_pos = display_bounds.x + (display_bounds.w - hor_res) / 2;
+                y_pos = display_bounds.y + (display_bounds.h - ver_res) / 2;
+                LV_LOG_USER("Window centered on display %d at (%d, %d) [display bounds: %dx%d at %d,%d]",
+                            display_num, x_pos, y_pos,
+                            display_bounds.w, display_bounds.h,
+                            display_bounds.x, display_bounds.y);
+            } else {
+                LV_LOG_WARN("Failed to get bounds for display %d, using SDL_WINDOWPOS_CENTERED", display_num);
+                x_pos = SDL_WINDOWPOS_CENTERED;
+                y_pos = SDL_WINDOWPOS_CENTERED;
+            }
+        } else {
+            LV_LOG_WARN("Invalid display number %d (available: 0-%d), using SDL_WINDOWPOS_CENTERED",
+                        display_num, num_displays - 1);
+            x_pos = SDL_WINDOWPOS_CENTERED;
+            y_pos = SDL_WINDOWPOS_CENTERED;
+        }
+    }
+    else if (xpos_env != NULL && ypos_env != NULL) {
+        /* Use exact coordinates if both X and Y are specified */
+        x_pos = atoi(xpos_env);
+        y_pos = atoi(ypos_env);
+        LV_LOG_USER("Window position set to exact coordinates (%d, %d)", x_pos, y_pos);
+    }
+
+    dsc->window = SDL_CreateWindow("HelixScreen",
+                                   x_pos, y_pos,
                                    hor_res, ver_res, flag);       /*last param. SDL_WINDOW_BORDERLESS to hide borders*/
+
+    /* If we calculated an explicit position, set it again after window creation
+     * to ensure it's honored (some window managers adjust initial position) */
+    if (display_env != NULL && x_pos != SDL_WINDOWPOS_UNDEFINED && x_pos != SDL_WINDOWPOS_CENTERED) {
+        SDL_SetWindowPosition(dsc->window, x_pos, y_pos);
+        LV_LOG_USER("Explicitly set window position to (%d, %d) after creation", x_pos, y_pos);
+    }
+
     if(!dsc->window) {
         LV_LOG_ERROR("Failed to create SDL window");
         return LV_RESULT_INVALID;
@@ -310,8 +384,59 @@ static lv_result_t window_create(lv_display_t * disp)
         return LV_RESULT_INVALID;
     }
 
+#ifdef __ANDROID__
+    /* On Android with FULLSCREEN_DESKTOP, the window is at the native surface
+     * size (e.g. 2272x954). We want LVGL to render at a logical resolution
+     * that preserves the aspect ratio but targets ~480px height for readable UI.
+     * SDL_RenderSetLogicalSize handles upscaling and touch coordinate mapping. */
+    {
+        int actual_w = 0, actual_h = 0;
+
+        /* Try multiple methods to get the real native display size.
+         * SDL_GetRendererOutputSize may return the requested (logical) size
+         * early in the lifecycle, so also try SDL_GetCurrentDisplayMode. */
+        SDL_Renderer * renderer = lv_sdl_backend_ops.get_renderer(disp);
+        SDL_GetRendererOutputSize(renderer, &actual_w, &actual_h);
+        __android_log_print(ANDROID_LOG_INFO, "HelixSDL",
+            "renderer output=%dx%d, requested=%dx%d", actual_w, actual_h, hor_res, ver_res);
+
+        if(actual_w <= hor_res && actual_h <= ver_res) {
+            SDL_DisplayMode mode;
+            if(SDL_GetCurrentDisplayMode(0, &mode) == 0) {
+                actual_w = mode.w;
+                actual_h = mode.h;
+            }
+            __android_log_print(ANDROID_LOG_INFO, "HelixSDL",
+                "display mode=%dx%d", actual_w, actual_h);
+        }
+
+        if(actual_w > hor_res && actual_h > ver_res) {
+            int32_t target_h = 480;
+            float scale = (float)actual_h / (float)target_h;
+            int32_t logical_w = (int32_t)((float)actual_w / scale);
+            int32_t logical_h = target_h;
+
+            SDL_RenderSetLogicalSize(renderer, logical_w, logical_h);
+
+            hor_res = logical_w;
+            ver_res = logical_h;
+            lv_display_set_resolution(disp, logical_w, logical_h);
+
+            __android_log_print(ANDROID_LOG_INFO, "HelixSDL",
+                "scaling: native %dx%d -> logical %dx%d (%.1fx)",
+                actual_w, actual_h, logical_w, logical_h, scale);
+        } else {
+            __android_log_print(ANDROID_LOG_WARN, "HelixSDL",
+                "no scaling: actual=%dx%d <= requested=%dx%d",
+                actual_w, actual_h, hor_res, ver_res);
+        }
+    }
+#endif
+
+#ifndef __ANDROID__
     /*Some platforms (e.g. Emscripten) seem to require setting the size again */
     SDL_SetWindowSize(dsc->window, hor_res, ver_res);
+#endif
     return LV_RESULT_OK;
 }
 
diff --git a/src/stdlib/builtin/lv_string_builtin.c b/src/stdlib/builtin/lv_string_builtin.c
index c998ee18a..f30839516 100644
--- a/src/stdlib/builtin/lv_string_builtin.c
+++ b/src/stdlib/builtin/lv_string_builtin.c
@@ -258,6 +258,7 @@ int lv_strncmp(const char * s1, const char * s2, size_t len)
 
 char * lv_strdup(const char * src)
 {
+    if(src == NULL) return NULL;
     size_t len = lv_strlen(src) + 1;
     char * dst = lv_malloc(len);
     if(dst == NULL) return NULL;
diff --git a/src/stdlib/clib/lv_string_clib.c b/src/stdlib/clib/lv_string_clib.c
index 97acfaa99..ea3639d86 100644
--- a/src/stdlib/clib/lv_string_clib.c
+++ b/src/stdlib/clib/lv_string_clib.c
@@ -98,6 +98,7 @@ int lv_strncmp(const char * s1, const char * s2, size_t len)
 
 char * lv_strdup(const char * src)
 {
+    if(src == NULL) return NULL;
     /*strdup uses malloc, so use the lv_malloc when LV_USE_STDLIB_MALLOC is not LV_STDLIB_CLIB */
     size_t len = lv_strlen(src) + 1;
     char * dst = lv_malloc(len);
diff --git a/src/themes/default/lv_theme_default.c b/src/themes/default/lv_theme_default.c
index 4ffb30b27..d66417533 100644
--- a/src/themes/default/lv_theme_default.c
+++ b/src/themes/default/lv_theme_default.c
@@ -40,9 +40,9 @@ typedef struct _my_theme_t my_theme_t;
 #define BORDER_WIDTH            LV_DPX_CALC(theme->disp_dpi, 2)
 #define OUTLINE_WIDTH           LV_DPX_CALC(theme->disp_dpi, 3)
 
-#define PAD_DEF     LV_DPX_CALC(theme->disp_dpi, theme->disp_size == DISP_LARGE ? 24 : theme->disp_size == DISP_MEDIUM ? 20 : 16)
-#define PAD_SMALL   LV_DPX_CALC(theme->disp_dpi, theme->disp_size == DISP_LARGE ? 14 : theme->disp_size == DISP_MEDIUM ? 12 : 10)
-#define PAD_TINY    LV_DPX_CALC(theme->disp_dpi, theme->disp_size == DISP_LARGE ? 8 : theme->disp_size == DISP_MEDIUM ? 6 : 2)
+#define PAD_DEF     LV_DPX_CALC(theme->disp_dpi, theme->disp_size == DISP_LARGE ? 20 : theme->disp_size == DISP_MEDIUM ? 16 : 12)
+#define PAD_SMALL   LV_DPX_CALC(theme->disp_dpi, theme->disp_size == DISP_LARGE ? 12 : theme->disp_size == DISP_MEDIUM ? 10 : 8)
+#define PAD_TINY    LV_DPX_CALC(theme->disp_dpi, theme->disp_size == DISP_LARGE ? 6 : theme->disp_size == DISP_MEDIUM ? 4 : 2)
 
 /**********************
  *      TYPEDEFS
@@ -643,8 +643,8 @@ lv_theme_t * lv_theme_default_init(lv_display_t * disp, lv_color_t color_primary
     int32_t greater_res = LV_MAX(hor_res, ver_res);
     disp_size_t new_size;
 
-    if(greater_res <= 320) new_size = DISP_SMALL;
-    else if(greater_res < 720) new_size = DISP_MEDIUM;
+    if(greater_res <= 480) new_size = DISP_SMALL;
+    else if(greater_res <= 800) new_size = DISP_MEDIUM;
     else new_size = DISP_LARGE;
 
     /* check theme information whether will change or not*/
diff --git a/src/widgets/slider/lv_slider.c b/src/widgets/slider/lv_slider.c
index 8e8ade49d..18b15cda3 100644
--- a/src/widgets/slider/lv_slider.c
+++ b/src/widgets/slider/lv_slider.c
@@ -317,8 +317,9 @@ static void lv_slider_event(const lv_obj_class_t * class_p, lv_event_t * e)
             }
         }
         else if(indev_type == LV_INDEV_TYPE_POINTER) {
-            if(is_slider_horizontal(obj)) lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_VER);
-            else  lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_HOR);
+            /* Block perpendicular scroll while dragging (better touchscreen UX) */
+            if(is_slider_horizontal(obj)) lv_obj_remove_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_VER);
+            else  lv_obj_remove_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_HOR);
         }
     }
     else if(code == LV_EVENT_FOCUSED) {
@@ -328,13 +329,12 @@ static void lv_slider_event(const lv_obj_class_t * class_p, lv_event_t * e)
         }
     }
     else if(code == LV_EVENT_SIZE_CHANGED) {
+        /* Block perpendicular scroll chain (better touchscreen UX) */
         if(is_slider_horizontal(obj)) {
-            lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_VER);
-            lv_obj_remove_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_HOR);
+            lv_obj_remove_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_VER);
         }
         else {
-            lv_obj_add_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_HOR);
-            lv_obj_remove_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_VER);
+            lv_obj_remove_flag(obj, LV_OBJ_FLAG_SCROLL_CHAIN_HOR);
         }
         lv_obj_refresh_ext_draw_size(obj);
     }
