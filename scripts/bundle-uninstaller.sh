#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Bundle HelixScreen uninstaller into a single file
# Mirrors the approach used by bundle-installer.sh for install.sh
#
# Usage:
#   ./bundle-uninstaller.sh > uninstall.sh
#   ./bundle-uninstaller.sh -o uninstall.sh
#

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib/installer"
OUTPUT_FILE=""

# Parse arguments
while [ $# -gt 0 ]; do
    case "$1" in
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [-o output_file]"
            echo ""
            echo "Bundles the modular uninstaller into a single file."
            echo "If no output file specified, writes to stdout."
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# Generate the bundled uninstaller
generate_bundle() {
    # Header
    cat << 'HEADER'
#!/bin/sh
# Copyright (C) 2025-2026 356C LLC
# SPDX-License-Identifier: GPL-3.0-or-later
#
# HelixScreen Uninstaller
# This file is auto-generated by bundle-uninstaller.sh
#
# Usage:
#   ./uninstall.sh              # Interactive uninstall
#   ./uninstall.sh --force      # Skip confirmation prompt
#
# This script:
#   1. Stops HelixScreen
#   2. Removes init script or systemd service
#   3. Removes installation directory and caches
#   4. Re-enables previous UI (GuppyScreen, KlipperScreen, etc.)
#   5. Removes Moonraker update_manager section

# Fail fast on any error
set -e

# Configuration
GITHUB_REPO="prestonbrown/helixscreen"
SERVICE_NAME="helixscreen"

# Previous UIs we may need to re-enable (for scanning)
PREVIOUS_UIS="guppyscreen GuppyScreen featherscreen FeatherScreen klipperscreen KlipperScreen"

HEADER

    # Include each module (only those needed for uninstall)
    for module in common.sh platform.sh permissions.sh requirements.sh forgex.sh moonraker.sh uninstall.sh; do
        module_path="$LIB_DIR/$module"
        if [ ! -f "$module_path" ]; then
            echo "ERROR: Module not found: $module_path" >&2
            exit 1
        fi

        echo ""
        echo "# ============================================"
        echo "# Module: $module"
        echo "# ============================================"
        echo ""

        # Skip shebang, SPDX header, and source guard lines
        # Keep everything else
        awk '
            # Skip shebang
            /^#!/ { next }
            # Skip SPDX header
            /^# SPDX-License-Identifier:/ { next }
            # Skip module comment block at top (first few lines starting with #)
            NR <= 10 && /^# / { next }
            # Skip source guard
            /^\[ -n "\${_HELIX_.*_SOURCED:-}"/ { next }
            /_HELIX_.*_SOURCED=1/ { next }
            # Skip empty lines at the start
            NR <= 15 && /^$/ { next }
            # Print everything else
            { print }
        ' "$module_path"
    done

    # Include the main orchestration code
    cat << 'MAIN'

# ============================================
# Main orchestration
# ============================================

# Re-enable previous UI (extended version with scanning)
reenable_previous_ui() {
    log_info "Looking for previous screen UI to re-enable..."

    found_ui=false
    restored_xorg=false

    # For ForgeX firmware, do comprehensive cleanup and restore
    if [ "$AD5M_FIRMWARE" = "forge_x" ]; then
        uninstall_forgex

        if [ -n "$restored_ui" ]; then
            found_ui=true
        fi
    fi

    # For K1/Simple AF, check for GuppyScreen
    if [ "$platform" = "k1" ]; then
        for k1_ui in /etc/init.d/S99guppyscreen /etc/init.d/S50guppyscreen; do
            if [ -f "$k1_ui" ]; then
                log_info "Re-enabling GuppyScreen for K1..."
                $SUDO chmod +x "$k1_ui" 2>/dev/null || true
                if "$k1_ui" start 2>/dev/null; then
                    log_success "Re-enabled and started: $k1_ui"
                    found_ui=true
                    break
                fi
            fi
        done
    fi

    # For Klipper Mod, re-enable Xorg first (required for KlipperScreen)
    if [ "$AD5M_FIRMWARE" = "klipper_mod" ] || [ -f "/etc/init.d/S40xorg" ]; then
        if [ -f "/etc/init.d/S40xorg" ]; then
            log_info "Re-enabling Xorg display server..."
            $SUDO chmod +x "/etc/init.d/S40xorg" 2>/dev/null || true
            restored_xorg=true
        fi
    fi

    # Try the specific previous UI script for this firmware
    if [ -n "$PREVIOUS_UI_SCRIPT" ] && [ -f "$PREVIOUS_UI_SCRIPT" ]; then
        log_info "Found previous UI: $PREVIOUS_UI_SCRIPT"
        $SUDO chmod +x "$PREVIOUS_UI_SCRIPT" 2>/dev/null || true
        if "$PREVIOUS_UI_SCRIPT" start 2>/dev/null; then
            log_success "Re-enabled and started: $PREVIOUS_UI_SCRIPT"
            found_ui=true
        else
            log_warn "Re-enabled but failed to start: $PREVIOUS_UI_SCRIPT"
            log_warn "You may need to reboot"
            found_ui=true
        fi
    fi

    # Scan for other UIs we might have disabled
    for ui in $PREVIOUS_UIS; do
        for initscript in /etc/init.d/S*${ui}* /opt/config/mod/.root/S*${ui}*; do
            [ "$initscript" = "$PREVIOUS_UI_SCRIPT" ] && continue
            if [ -f "$initscript" ] 2>/dev/null; then
                log_info "Found previous UI: $initscript"
                $SUDO chmod +x "$initscript" 2>/dev/null || true
                if [ "$found_ui" = false ]; then
                    if "$initscript" start 2>/dev/null; then
                        log_success "Re-enabled and started: $initscript"
                        found_ui=true
                    else
                        log_warn "Re-enabled but failed to start: $initscript"
                        log_warn "You may need to reboot"
                        found_ui=true
                    fi
                else
                    log_info "Re-enabled: $initscript (not started, another UI already running)"
                fi
            fi
        done

        if [ "$INIT_SYSTEM" = "systemd" ]; then
            if systemctl list-unit-files "${ui}.service" >/dev/null 2>&1; then
                log_info "Found previous UI (systemd): $ui"
                $SUDO systemctl enable "$ui" 2>/dev/null || true
                if $SUDO systemctl start "$ui" 2>/dev/null; then
                    log_success "Re-enabled and started: $ui"
                    found_ui=true
                else
                    log_warn "Re-enabled but failed to start: $ui"
                    found_ui=true
                fi
            fi
        fi
    done

    # Re-enable tslib for ForgeX (if not already handled by uninstall_forgex)
    if [ -f "/opt/config/mod/.root/S35tslib" ]; then
        $SUDO chmod +x "/opt/config/mod/.root/S35tslib" 2>/dev/null || true
    fi

    if [ "$found_ui" = false ]; then
        log_info "No previous screen UI found to re-enable"
        log_info "If you had a stock UI, a reboot may restore it"
    fi

    if [ "$restored_xorg" = true ]; then
        log_info "Re-enabled: Xorg (/etc/init.d/S40xorg)"
    fi
}

# Stop HelixScreen processes and service
stop_helixscreen() {
    log_info "Stopping HelixScreen..."

    # Stop via init system
    if [ "$INIT_SYSTEM" = "systemd" ]; then
        $SUDO systemctl stop helixscreen 2>/dev/null || true
        $SUDO systemctl disable helixscreen 2>/dev/null || true
    fi

    # Stop via configured init script
    if [ -n "$INIT_SCRIPT_DEST" ] && [ -x "$INIT_SCRIPT_DEST" ]; then
        $SUDO "$INIT_SCRIPT_DEST" stop 2>/dev/null || true
    fi

    # Also check all possible init script locations
    for init_script in $HELIX_INIT_SCRIPTS; do
        if [ -x "$init_script" ]; then
            $SUDO "$init_script" stop 2>/dev/null || true
        fi
    done

    # Kill any remaining processes (watchdog first to prevent crash dialog flash)
    # shellcheck disable=SC2086
    kill_process_by_name $HELIX_PROCESSES || true

    log_success "HelixScreen stopped"
}

# Remove init script or systemd service
remove_service() {
    log_info "Removing service configuration..."

    if [ "$INIT_SYSTEM" = "systemd" ]; then
        if [ -f "/etc/systemd/system/helixscreen.service" ]; then
            $SUDO rm -f "/etc/systemd/system/helixscreen.service"
            $SUDO systemctl daemon-reload
            log_success "Removed systemd service"
        fi
    fi

    # Remove configured init script
    if [ -n "$INIT_SCRIPT_DEST" ] && [ -f "$INIT_SCRIPT_DEST" ]; then
        $SUDO rm -f "$INIT_SCRIPT_DEST"
        log_success "Removed SysV init script: $INIT_SCRIPT_DEST"
    fi

    # Also check and remove from all possible locations
    for init_script in $HELIX_INIT_SCRIPTS; do
        if [ -f "$init_script" ]; then
            $SUDO rm -f "$init_script"
            log_success "Removed SysV init script: $init_script"
        fi
    done
}

# Remove installation directory
remove_installation() {
    log_info "Removing installation..."

    removed_any=false

    # Re-enable services from state file BEFORE removing install dir
    reenable_disabled_services

    # Remove from configured location
    if [ -d "$INSTALL_DIR" ]; then
        $SUDO rm -rf "$INSTALL_DIR"
        log_success "Removed $INSTALL_DIR"
        removed_any=true
        # Also remove updater repo clone if present
        if [ -d "${INSTALL_DIR}-repo" ]; then
            $SUDO rm -rf "${INSTALL_DIR}-repo"
            log_success "Removed ${INSTALL_DIR}-repo"
        fi
    fi

    # Also check and remove from all possible locations
    for install_dir in $HELIX_INSTALL_DIRS; do
        if [ -d "$install_dir" ] && [ "$install_dir" != "$INSTALL_DIR" ]; then
            $SUDO rm -rf "$install_dir"
            log_success "Removed $install_dir"
            removed_any=true
            if [ -d "${install_dir}-repo" ]; then
                $SUDO rm -rf "${install_dir}-repo"
                log_success "Removed ${install_dir}-repo"
            fi
        fi
    done

    if [ "$removed_any" = false ]; then
        log_warn "No HelixScreen installation found (already removed?)"
    fi

    # Clean up PID files, log file, and active flag
    $SUDO rm -f /var/run/helixscreen.pid 2>/dev/null || true
    $SUDO rm -f /var/run/helix-splash.pid 2>/dev/null || true
    $SUDO rm -f /tmp/helixscreen.log 2>/dev/null || true
    $SUDO rm -f /tmp/helixscreen_active 2>/dev/null || true

    # Clean up cache directories
    for cache_dir in /root/.cache/helix /tmp/helix_thumbs /.cache/helix; do
        if [ -d "$cache_dir" ] 2>/dev/null; then
            log_info "Removing cache: $cache_dir"
            $SUDO rm -rf "$cache_dir"
        fi
    done

    # Clean up macOS resource fork files (created by scp from Mac)
    for pattern in /opt/._helixscreen /root/._helixscreen; do
        $SUDO rm -f "$pattern" 2>/dev/null || true
    done
}

# Main uninstall
main() {
    force=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --force|-f)
                force=true
                shift
                ;;
            --help|-h)
                echo "HelixScreen Uninstaller"
                echo ""
                echo "Usage: $0 [options]"
                echo ""
                echo "Options:"
                echo "  --force, -f   Skip confirmation prompt"
                echo "  --help, -h    Show this help message"
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    echo ""
    echo "${CYAN}========================================${NC}"
    echo "${CYAN}     HelixScreen Uninstaller${NC}"
    echo "${CYAN}========================================${NC}"
    echo ""

    # Detect platform and firmware to set correct paths
    platform=$(detect_platform)
    if [ "$platform" = "ad5m" ]; then
        AD5M_FIRMWARE=$(detect_ad5m_firmware)
        log_info "Detected AD5M firmware: $AD5M_FIRMWARE"
    fi
    set_install_paths "$platform" "$AD5M_FIRMWARE"

    # Check for root
    check_permissions "$platform"

    # Detect init system
    detect_init_system

    # Confirm unless --force
    if [ "$force" = false ]; then
        echo "This will:"
        echo "  - Stop HelixScreen"
        echo "  - Remove $INSTALL_DIR"
        echo "  - Remove service configuration"
        echo "  - Re-enable previous screen UI (if found)"
        if [ "$AD5M_FIRMWARE" = "forge_x" ]; then
            echo "  - Restore ForgeX display configuration (GuppyScreen)"
        fi
        echo ""
        printf "Are you sure you want to continue? [y/N] "
        read -r response
        case "$response" in
            [yY][eE][sS]|[yY])
                ;;
            *)
                log_info "Uninstall cancelled"
                exit 0
                ;;
        esac
        echo ""
    fi

    # Perform uninstall
    stop_helixscreen
    remove_service
    remove_installation
    reenable_previous_ui
    remove_update_manager_section || true

    echo ""
    echo "${GREEN}========================================${NC}"
    echo "${GREEN}    Uninstall Complete!${NC}"
    echo "${GREEN}========================================${NC}"
    echo ""
    log_info "HelixScreen has been removed."
    log_info "A reboot is recommended to ensure clean state."
    echo ""
}

# Only run when executed directly (not when sourced for testing)
case "${0##*/}" in
    uninstall.sh) main "$@" ;;
esac
MAIN
}

# Output to file or stdout
if [ -n "$OUTPUT_FILE" ]; then
    generate_bundle > "$OUTPUT_FILE"
    chmod +x "$OUTPUT_FILE"
    echo "Generated: $OUTPUT_FILE"
    echo "Size: $(wc -c < "$OUTPUT_FILE" | tr -d ' ') bytes"
else
    generate_bundle
fi
