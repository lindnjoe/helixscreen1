#!/usr/bin/env bats
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Tests for the self-contained uninstall.sh
# Verifies the bundled script works correctly without lib/ dependencies

WORKTREE_ROOT="$(cd "$BATS_TEST_DIRNAME/../.." && pwd)"

setup() {
    load helpers

    # Source the bundled uninstall.sh (the case guard skips main)
    . "$WORKTREE_ROOT/scripts/uninstall.sh"

    # Override globals for testing
    export INSTALL_DIR="$BATS_TEST_TMPDIR/opt/helixscreen"
    export HELIX_INSTALL_DIRS="$BATS_TEST_TMPDIR/opt/helixscreen"
    export HELIX_INIT_SCRIPTS=""
    export HELIX_PROCESSES=""
    export PREVIOUS_UIS=""
    export PREVIOUS_UI_SCRIPT=""
    export INIT_SYSTEM="sysv"
    export AD5M_FIRMWARE=""
    export SUDO=""
}

# ============================================================================
# Self-contained verification
# ============================================================================

@test "uninstall.sh is auto-generated by bundle-uninstaller.sh" {
    grep -q "auto-generated by bundle-uninstaller.sh" "$WORKTREE_ROOT/scripts/uninstall.sh"
}

@test "uninstall.sh does not source lib/installer modules" {
    ! grep -q '\. .*lib/installer' "$WORKTREE_ROOT/scripts/uninstall.sh"
}

@test "uninstall.sh has all required functions defined" {
    # Core functions that must be present
    for func in detect_platform detect_ad5m_firmware set_install_paths \
                check_permissions detect_init_system \
                restore_stock_firmware_ui unpatch_forgex_screen_sh \
                unpatch_forgex_screen_drawing uninstall_forgex_logged_wrapper \
                find_moonraker_conf remove_update_manager_section \
                reenable_disabled_services kill_process_by_name; do
        grep -q "^${func}()" "$WORKTREE_ROOT/scripts/uninstall.sh" || \
        grep -q "^${func} ()" "$WORKTREE_ROOT/scripts/uninstall.sh"
    done
}

@test "uninstall.sh does not run main when sourced" {
    # Sourcing the file in setup() should not have called main
    # If main ran, it would have tried to detect platform and possibly exit
    # The fact we got here means the source guard works
    [ -n "$HELIX_INSTALL_DIRS" ]
}

# ============================================================================
# Argument parsing
# ============================================================================

@test "main --help exits 0" {
    run main --help
    [ "$status" -eq 0 ]
    echo "$output" | grep -q "HelixScreen Uninstaller"
}

@test "main --help shows --force option" {
    run main --help
    echo "$output" | grep -q "\-\-force"
}

@test "main rejects unknown options" {
    # Override platform/permission functions to prevent actual detection
    detect_platform() { echo "unsupported"; }
    set_install_paths() { :; }
    check_permissions() { :; }
    detect_init_system() { INIT_SYSTEM="sysv"; }

    run main --bogus
    [ "$status" -eq 1 ]
}

# ============================================================================
# stop_helixscreen
# ============================================================================

@test "stop_helixscreen succeeds with no services running" {
    INIT_SYSTEM="sysv"
    INIT_SCRIPT_DEST=""
    HELIX_INIT_SCRIPTS=""
    HELIX_PROCESSES=""

    run stop_helixscreen
    [ "$status" -eq 0 ]
}

@test "stop_helixscreen tries all init script locations" {
    local log="$BATS_TEST_TMPDIR/stop.log"

    # Create fake init scripts
    local script1="$BATS_TEST_TMPDIR/S80helixscreen"
    local script2="$BATS_TEST_TMPDIR/S90helixscreen"
    printf '#!/bin/sh\necho "stop $0" >> "%s"\n' "$log" > "$script1"
    printf '#!/bin/sh\necho "stop $0" >> "%s"\n' "$log" > "$script2"
    chmod +x "$script1" "$script2"

    INIT_SYSTEM="sysv"
    INIT_SCRIPT_DEST=""
    HELIX_INIT_SCRIPTS="$script1 $script2"
    HELIX_PROCESSES=""

    stop_helixscreen
    [ -f "$log" ]
    [ "$(wc -l < "$log" | tr -d ' ')" -eq 2 ]
}

# ============================================================================
# remove_service
# ============================================================================

@test "remove_service removes sysv init scripts" {
    local script="$BATS_TEST_TMPDIR/S90helixscreen"
    touch "$script"

    INIT_SYSTEM="sysv"
    INIT_SCRIPT_DEST="$script"
    HELIX_INIT_SCRIPTS=""

    remove_service
    [ ! -f "$script" ]
}

@test "remove_service removes all known init script locations" {
    local s1="$BATS_TEST_TMPDIR/S80"
    local s2="$BATS_TEST_TMPDIR/S90"
    touch "$s1" "$s2"

    INIT_SYSTEM="sysv"
    INIT_SCRIPT_DEST=""
    HELIX_INIT_SCRIPTS="$s1 $s2"

    remove_service
    [ ! -f "$s1" ]
    [ ! -f "$s2" ]
}

# ============================================================================
# remove_installation
# ============================================================================

@test "remove_installation removes install directory" {
    mkdir -p "$INSTALL_DIR/bin"
    touch "$INSTALL_DIR/bin/helix-screen"

    remove_installation
    [ ! -d "$INSTALL_DIR" ]
}

@test "remove_installation removes updater repo clone" {
    mkdir -p "$INSTALL_DIR"
    mkdir -p "${INSTALL_DIR}-repo"

    remove_installation
    [ ! -d "${INSTALL_DIR}-repo" ]
}

@test "remove_installation removes PID files" {
    local pid_dir="$BATS_TEST_TMPDIR/var/run"
    mkdir -p "$pid_dir"
    touch "$pid_dir/helixscreen.pid"
    touch "$pid_dir/helix-splash.pid"

    # Can't test /var/run directly, but verify the function completes
    mkdir -p "$INSTALL_DIR"
    run remove_installation
    [ "$status" -eq 0 ]
}

@test "remove_installation cleans cache directories" {
    local cache="$BATS_TEST_TMPDIR/helix_thumbs"
    mkdir -p "$cache"
    mkdir -p "$INSTALL_DIR"

    # Override HELIX_INSTALL_DIRS to only check our test dir
    HELIX_INSTALL_DIRS="$INSTALL_DIR"

    # Can't test system cache dirs, but verify no crash
    run remove_installation
    [ "$status" -eq 0 ]
}

@test "remove_installation warns when no installation found" {
    INSTALL_DIR="$BATS_TEST_TMPDIR/nonexistent"
    HELIX_INSTALL_DIRS="$BATS_TEST_TMPDIR/also_nonexistent"

    run remove_installation
    [ "$status" -eq 0 ]
}

@test "remove_installation checks all HELIX_INSTALL_DIRS" {
    local dir1="$BATS_TEST_TMPDIR/dir1"
    local dir2="$BATS_TEST_TMPDIR/dir2"
    mkdir -p "$dir1" "$dir2"

    INSTALL_DIR="$BATS_TEST_TMPDIR/primary"  # doesn't exist
    HELIX_INSTALL_DIRS="$dir1 $dir2"

    remove_installation
    [ ! -d "$dir1" ]
    [ ! -d "$dir2" ]
}

@test "remove_installation calls reenable_disabled_services before removing" {
    mkdir -p "$INSTALL_DIR/config"

    # Create a state file with a test entry
    local test_script="$BATS_TEST_TMPDIR/S99test"
    touch "$test_script"
    chmod -x "$test_script"
    echo "sysv-chmod:$test_script" > "$INSTALL_DIR/config/.disabled_services"

    remove_installation

    # The script should have been re-enabled before the dir was removed
    [ -x "$test_script" ]
    [ ! -d "$INSTALL_DIR" ]
}

# ============================================================================
# reenable_disabled_services (in the bundled context)
# ============================================================================

@test "reenable_disabled_services handles missing state file" {
    INSTALL_DIR="$BATS_TEST_TMPDIR/no_install"
    run reenable_disabled_services
    [ "$status" -eq 0 ]
}

@test "reenable_disabled_services re-enables sysv scripts" {
    mkdir -p "$INSTALL_DIR/config"
    local script="$BATS_TEST_TMPDIR/S40xorg"
    touch "$script"
    chmod -x "$script"

    echo "sysv-chmod:$script" > "$INSTALL_DIR/config/.disabled_services"

    reenable_disabled_services
    [ -x "$script" ]
}

# ============================================================================
# Moonraker (remove_update_manager_section)
# ============================================================================

@test "remove_update_manager_section cleans moonraker.conf" {
    local conf="$BATS_TEST_TMPDIR/moonraker.conf"
    cat > "$conf" << 'CONF'
[server]
host: 0.0.0.0

# HelixScreen Update Manager
# Added by HelixScreen installer - enables one-click updates
[update_manager helixscreen]
type: zip
channel: stable
repo: prestonbrown/helixscreen
path: /opt/helixscreen
managed_services: helixscreen

[update_manager mainsail]
type: web
CONF

    KLIPPER_HOME=""
    MOONRAKER_CONF_PATHS="$conf"

    remove_update_manager_section

    # helixscreen section should be gone
    ! grep -q 'update_manager helixscreen' "$conf"
    # mainsail section should remain
    grep -q 'update_manager mainsail' "$conf"
    # server section should remain
    grep -q '\[server\]' "$conf"
}

@test "remove_update_manager_section handles no moonraker.conf" {
    KLIPPER_HOME=""
    MOONRAKER_CONF_PATHS="/nonexistent/moonraker.conf"

    run remove_update_manager_section
    [ "$status" -eq 0 ]
}

@test "remove_update_manager_section handles no helixscreen section" {
    local conf="$BATS_TEST_TMPDIR/moonraker.conf"
    cat > "$conf" << 'CONF'
[server]
host: 0.0.0.0
CONF

    KLIPPER_HOME=""
    MOONRAKER_CONF_PATHS="$conf"

    run remove_update_manager_section
    [ "$status" -eq 0 ]
    grep -q '\[server\]' "$conf"
}

# ============================================================================
# ForgeX helpers
# ============================================================================

@test "restore_stock_firmware_ui restores commented line" {
    local auto_run="$BATS_TEST_TMPDIR/auto_run.sh"
    echo "# Disabled by HelixScreen: /opt/PROGRAM/ffstartup-arm" > "$auto_run"

    # Override to use test path (original is hardcoded to /opt/auto_run.sh)
    # Use awk instead of sed -i to avoid macOS/GNU incompatibility
    restore_stock_firmware_ui() {
        local auto_run="$BATS_TEST_TMPDIR/auto_run.sh"
        if [ -f "$auto_run" ]; then
            if grep -q "^# Disabled by HelixScreen: /opt/PROGRAM/ffstartup-arm" "$auto_run"; then
                local tmp="${auto_run}.tmp"
                awk '{gsub(/^# Disabled by HelixScreen: \/opt\/PROGRAM\/ffstartup-arm/, "/opt/PROGRAM/ffstartup-arm"); print}' "$auto_run" > "$tmp"
                mv "$tmp" "$auto_run"
                return 0
            fi
        fi
        return 1
    }

    restore_stock_firmware_ui
    grep -q "^/opt/PROGRAM/ffstartup-arm" "$auto_run"
}

@test "uninstall_forgex_logged_wrapper handles not-installed" {
    # No logged-real file means wrapper isn't installed
    run uninstall_forgex_logged_wrapper
    [ "$status" -eq 0 ]
}

# ============================================================================
# kill_process_by_name
# ============================================================================

@test "kill_process_by_name returns 1 when no processes found" {
    # Mock killall to always fail (no such process)
    mock_command_fail "killall"
    mock_command_fail "pidof"

    run kill_process_by_name nonexistent_process
    [ "$status" -eq 1 ]
}

# ============================================================================
# Bundle regeneration
# ============================================================================

@test "bundle-uninstaller.sh regenerates identical output" {
    local regenerated="$BATS_TEST_TMPDIR/uninstall-regen.sh"
    "$WORKTREE_ROOT/scripts/bundle-uninstaller.sh" -o "$regenerated"

    # Compare with checked-in version
    diff "$WORKTREE_ROOT/scripts/uninstall.sh" "$regenerated"
}

@test "bundle-uninstaller.sh output passes sh -n syntax check" {
    sh -n "$WORKTREE_ROOT/scripts/uninstall.sh"
}

# ============================================================================
# Robustness: partial/corrupt state, missing dependencies, permission issues
# ============================================================================

@test "remove_installation handles partially removed install (bin gone, config remains)" {
    mkdir -p "$INSTALL_DIR/config"
    echo '{}' > "$INSTALL_DIR/config/helixconfig.json"
    # bin/ directory is missing (partially removed)

    run remove_installation
    [ "$status" -eq 0 ]
    [ ! -d "$INSTALL_DIR" ]
}

@test "remove_installation handles empty install directory" {
    mkdir -p "$INSTALL_DIR"
    # Directory exists but is empty

    run remove_installation
    [ "$status" -eq 0 ]
    [ ! -d "$INSTALL_DIR" ]
}

@test "remove_installation handles multiple install locations simultaneously" {
    # Simulate a messy state: helix installed in two places
    local dir1="$BATS_TEST_TMPDIR/location1"
    local dir2="$BATS_TEST_TMPDIR/location2"
    mkdir -p "$dir1/bin" "$dir2/bin"
    touch "$dir1/bin/helix-screen" "$dir2/bin/helix-screen"

    INSTALL_DIR="$dir1"
    HELIX_INSTALL_DIRS="$dir1 $dir2"

    remove_installation
    [ ! -d "$dir1" ]
    [ ! -d "$dir2" ]
}

@test "stop_helixscreen succeeds even when systemctl is missing" {
    INIT_SYSTEM="sysv"
    INIT_SCRIPT_DEST=""
    HELIX_INIT_SCRIPTS=""
    HELIX_PROCESSES=""

    # Ensure no systemctl is available
    mock_command_fail "systemctl"

    run stop_helixscreen
    [ "$status" -eq 0 ]
}

@test "stop_helixscreen handles init scripts that fail to stop" {
    local script="$BATS_TEST_TMPDIR/S90helixscreen"
    printf '#!/bin/sh\nexit 1\n' > "$script"
    chmod +x "$script"

    INIT_SYSTEM="sysv"
    INIT_SCRIPT_DEST="$script"
    HELIX_INIT_SCRIPTS=""
    HELIX_PROCESSES=""

    # Should not fail even if stop returns error
    run stop_helixscreen
    [ "$status" -eq 0 ]
}

@test "remove_service handles already-removed init scripts" {
    INIT_SYSTEM="sysv"
    INIT_SCRIPT_DEST="$BATS_TEST_TMPDIR/nonexistent_script"
    HELIX_INIT_SCRIPTS="$BATS_TEST_TMPDIR/also_gone"

    run remove_service
    [ "$status" -eq 0 ]
}

@test "reenable_disabled_services handles corrupt state file" {
    mkdir -p "$INSTALL_DIR/config"
    # Write garbage to state file
    printf "not_a_valid_type:something\nbadformat\n:::colons:::\n" > "$INSTALL_DIR/config/.disabled_services"

    run reenable_disabled_services
    [ "$status" -eq 0 ]
}

@test "reenable_disabled_services handles state file with only comments" {
    mkdir -p "$INSTALL_DIR/config"
    printf "# This is a comment\n# Another comment\n" > "$INSTALL_DIR/config/.disabled_services"

    run reenable_disabled_services
    [ "$status" -eq 0 ]
}

@test "remove_update_manager_section handles malformed moonraker.conf" {
    local conf="$BATS_TEST_TMPDIR/moonraker.conf"
    # Partial/truncated file
    printf "[update_manager helixscreen]\ntype: zip\nchannel:" > "$conf"

    KLIPPER_HOME=""
    MOONRAKER_CONF_PATHS="$conf"

    run remove_update_manager_section
    [ "$status" -eq 0 ]
    # File should still exist
    [ -f "$conf" ]
}

@test "remove_update_manager_section creates backup before modifying" {
    local conf="$BATS_TEST_TMPDIR/moonraker.conf"
    cat > "$conf" << 'CONF'
[server]
host: 0.0.0.0

[update_manager helixscreen]
type: zip
CONF

    KLIPPER_HOME=""
    MOONRAKER_CONF_PATHS="$conf"

    remove_update_manager_section

    # Backup should exist
    [ -f "${conf}.bak.helixscreen-uninstall" ]
    # Backup should contain the original content
    grep -q 'update_manager helixscreen' "${conf}.bak.helixscreen-uninstall"
}

@test "remove_installation preserves non-helixscreen directories" {
    local other_dir="$BATS_TEST_TMPDIR/other_software"
    mkdir -p "$other_dir"
    touch "$other_dir/important_file"

    mkdir -p "$INSTALL_DIR"
    HELIX_INSTALL_DIRS="$INSTALL_DIR"

    remove_installation

    # Other directory should be untouched
    [ -d "$other_dir" ]
    [ -f "$other_dir/important_file" ]
}

@test "stop_helixscreen handles mixed init systems gracefully" {
    # Neither systemd nor init scripts exist
    INIT_SYSTEM="sysv"
    INIT_SCRIPT_DEST="$BATS_TEST_TMPDIR/nonexistent"
    HELIX_INIT_SCRIPTS="$BATS_TEST_TMPDIR/also_nonexistent"
    HELIX_PROCESSES="fake_helix_process"
    mock_command_fail "killall"
    mock_command_fail "pidof"

    run stop_helixscreen
    [ "$status" -eq 0 ]
}

@test "remove_installation handles read-only install dir gracefully" {
    # This tests that we don't crash on permission errors
    # (SUDO="" means no privilege escalation in tests)
    mkdir -p "$INSTALL_DIR"

    # Run as normal - should succeed since we own the dir
    run remove_installation
    [ "$status" -eq 0 ]
}

# ============================================================================
# Regression: key patterns must exist in generated output
# ============================================================================

@test "regression: uninstall.sh handles HEADLESS display mode" {
    grep -q "HEADLESS" "$WORKTREE_ROOT/scripts/uninstall.sh"
}

@test "regression: uninstall.sh handles STOCK display mode" {
    grep -q "'STOCK'" "$WORKTREE_ROOT/scripts/uninstall.sh"
}

@test "regression: uninstall.sh cleans macOS resource forks" {
    grep -q "\._helixscreen" "$WORKTREE_ROOT/scripts/uninstall.sh"
}

@test "regression: uninstall.sh cleans cache directories" {
    grep -q "helix_thumbs" "$WORKTREE_ROOT/scripts/uninstall.sh"
}

@test "regression: uninstall.sh handles logged wrapper removal" {
    grep -q "logged-real" "$WORKTREE_ROOT/scripts/uninstall.sh"
}

@test "regression: uninstall.sh kills watchdog before screen" {
    # Watchdog must be killed BEFORE helix-screen to prevent crash dialog
    local watchdog_line
    local screen_line
    watchdog_line=$(grep -n "helix-watchdog" "$WORKTREE_ROOT/scripts/uninstall.sh" | grep "HELIX_PROCESSES" | head -1 | cut -d: -f1)
    [ -n "$watchdog_line" ]

    # In HELIX_PROCESSES, watchdog should come before screen
    grep "HELIX_PROCESSES=" "$WORKTREE_ROOT/scripts/uninstall.sh" | grep -q "helix-watchdog.*helix-screen"
}

@test "regression: uninstall.sh removes helixscreen_active flag" {
    grep -q "helixscreen_active" "$WORKTREE_ROOT/scripts/uninstall.sh"
}

@test "regression: uninstall.sh handles all three init script locations" {
    grep -q "S80helixscreen" "$WORKTREE_ROOT/scripts/uninstall.sh"
    grep -q "S90helixscreen" "$WORKTREE_ROOT/scripts/uninstall.sh"
    grep -q "S99helixscreen" "$WORKTREE_ROOT/scripts/uninstall.sh"
}

@test "regression: uninstall.sh checks all install dir locations" {
    grep -q "/root/printer_software/helixscreen" "$WORKTREE_ROOT/scripts/uninstall.sh"
    grep -q "/opt/helixscreen" "$WORKTREE_ROOT/scripts/uninstall.sh"
    grep -q "/usr/data/helixscreen" "$WORKTREE_ROOT/scripts/uninstall.sh"
}
